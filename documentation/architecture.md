# Gam3du architecture

This document describes the components of this project and how they play together.

## Framework

The framework (located under `framework`) covers the fundamental building block of every application. It is agnostic to any specific [engine](#engine), scripting language or [API](#apis) but enables a developer to integrate any of these.

Some of the main functions of the framework:

- locating and loading resources
- abstracting the platform (graphics, sound, input, operating system, ...)
- starting the scripting runtimes (e.g. Python VM, WASM, ...)
- loading an engine
- bringing the engines's outputs to the screen
- logging

## Engine

An engine is the core part of an application. It handles all inputs and events, implements the application logic or game loop and creates the visible output.

While _Gam3du_ may include multiple engines only one engine can be loaded at a time.

At the time of writing only a single engine will be compiled into each binary. This might change in the future.

An engine exposes an API, enabling scripts to control it.

## APIs

An API describes what commands and events a module exposes to other scripts. There are two types of APIs:

- (static) built-in APIs (engine and framework)
- (dynamic) user APIs (user scripts)

Built-in APIs are faster but can only be changed by recompiling the binary. Dynamic APIs on the other hand only require a restart of the binary to become active.

The API-description is a JSON file which will be used to generate [bindings](#binding) for [runtimes](#runtime).

## Module, Mods

A module is a user-provided program that makes use of the engine or extends (modified, hence _mod_) other modules. A module's scope ranges from an entire game-engine to a small addition to an existing application.

Modules depend on each other and can access each other's API. Each module can be written in a different programming language and will be loaded in their own runtime.

A module contains the scripts to run, resources (images, sounds, configuration) and maybe a local store and/or cache.

It is an open question whether the loaded engine shall be considered a built-in/native module.

## Runtime

A runtime is the environment where each module's scripts runs. There will be one instance per module.

At the time of writing we assume the following runtimes are realistic to provide:

- Python
- Lua
- Javascript
- WebAssembly (WASM)
- Websocket (e.g. JSON-RPC)
- Http-Requests

## Binding

In order for a Runtime to interact with the running application a _binding_ will be used. Bindings are being generated by the API description. For built-in APIs the bindings will be generated at compile-time. For dynamic APIs (only known at runtime) a generic method providing the [command pattern](https://en.wikipedia.org/wiki/Command_pattern) will be generated.
